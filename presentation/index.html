<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/dracula.css" />

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		<script src="plugin/highlight/highlight.js"></script>
		<script>
		Reveal.initialize({
			plugins: [RevealHighlight],
		});
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Recorrido del Caballo de Ajedrez</h3>
					<p>
						<img src="chess_horse.svg" alt="horse logo" style="height: 100px; background: transparent;" class="logo">
					</p>
					<p><strong>Materia:</strong> Programaci贸n 3</p>
					<small>
						<p>
							Integrantes:
							<p><a> Del Vecchio, Mathias </a></p>
							<p><a> Hernandez, Guillermo </a></p>
							<p><a> Huaman, Cecilia </a></p>
						</p>
					</small>
					
				</section>
				<section>
					<h4>Descripci贸n</h4>
					<small>
						<p>
							Dado un tablero de ajedrez de tama帽o NN y una posici贸n inicial para el caballo,
							el objetivo es encontrar un camino en el que el caballo visite cada casilla
							exactamente una vez. El caballo se mueve en forma de "L", es decir, dos casillas en
							una direcci贸n (vertical u horizontal) y luego una casilla en una direcci贸n
							perpendicular, o una casilla en una direcci贸n y dos casillas en la perpendicular.
						</p>
						<p><strong>Total de 8 movimientos posibles a evaluar</strong></p>
						<img src="https://snakify.org/static/images/problems/knight_move.png">
					</small>
				</section>
				<section>
					<h3>Implementaci贸n</h3>
					<p><strong>Backtracking</strong></p>
				</section>
				<section>
					<h4>Pseudoc贸digo</h4>
					<textarea style="border: 2px solid #333; padding: 20px; background-color: #44475A; color: white; width: 100%; height: 550px; font-size: 16px; font-family: monospace; white-space: pre-wrap; overflow: auto;" readonly >
generarTablero(n) //genero matriz nxn con -1
					
	Inicializar movimientos_x=[] //[2, 1, -1, -2, -2, -1, 1, 2]
	Inicializar movimientos_y=[] //[1, 2, 2, 1, -1, -2, -2, -1]
	tablero[pos_x][pos_y]=0 //Inicializo posici贸n inicial
							
	pos = 1 //primera posicion
							
	Si pos recorri贸 todos los casilleros 
		Muestro el tablero //print

		Si no los recorri贸, chequeo el primero movimiento posible de los 8 posibles que 
		puede hacer un caballero en un escaque posible 
		//new_x = curr_x + move_x[i] new_y = curr_y + move_y[i]

		Pregunto si es factible 
		//Si x e y se encuentran dentro de los l铆mites del tablero
		//Y que el caballero no haya pasado por ese escaque
							
			Si lo es, muevo el caballero a la nueva posici贸n.
			//board[new_x][new_y] = pos

				Hago recursividad desde el nuevo escaque y chequeo movimientos 
				posibles nuevamente pero a partir de ah铆
				#if(factible(n, board, new_x, new_y, move_x, move_y, pos+1)):
			
			Si no lo es, vuelvo un movimiento atr谩s y pruebo desde el pr贸ximo 
			movimiento posible.
			//board[new_x][new_y] = -1
			//i++
							
	Si no tengo mas movimientos imprimo que no hay soluci贸n
					</textarea>
				</section>
				<section>
					<h4>Algoritmo Backtracking</h4>
					<code class="language-python" data-line-numbers="1-6|8|13|14-15|17-21|29-30|22-23|13|14-21|26|17-21|27|9"><pre>
			def solveKT(n: int):
						board = [[-1 for _ in range(n)] for _ in range(n)]
						move_x = [2, 1, -1, -2, -2, -1, 1, 2]
						move_y = [1, 2, 2, 1, -1, -2, -2, -1]
						board[x_position][y_position] = 0
						pos = 1
						
						if not solveKTUtil(n, board , x_position, y_position, move_x , move_y , pos):
							print("Solution does not exist")
						else:
							printSolution(n, board )         
					
			def solveKTUtil(n, board , curr_x: int, curr_y: int, move_x, move_y, pos):
						if pos == n**2:
							return True
						
						for i in range(8):
							new_x = curr_x + move_x[i]
							new_y = curr_y + move_y[i]
									
							if isSafe(new_x, new_y, board, n):  
								board[new_x][new_y] = pos
								if solveKTUtil(n, board, new_x, new_y, move_x, move_y, pos + 1):
									return True
						
							board[new_x][new_y] = -1		   
						return False
					
			def isSafe(x, y, board, size):
						return 0 <= x < size and 0 <= y < size and board[x][y] == -1  

				</code></pre>
				</section>
				<section>
					<h4>Costo</h4>
					<p style="color: rgb(220, 183, 20); font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;">Exponencial</p>
					<div style="background-color: #2E3440; padding: 10px; border-radius: 8px; margin-bottom: 13px;">
					<small >
						
La complejidad temporal de este problema utilizando Backtracking normalmente <br>
se analiza como <strong>(8^N^2)</strong>, donde: <br><br>
<ul>
	<li>N es el tama帽o del tablero de ajedrez. Un tablero de ajedrez N x N tiene N^2 casillas.<br></li>
	<li>Movimientos m谩ximos por casilla: en cada casilla, el caballero puede realizar como m谩ximo 8 movimientos posibles.<br></li>
</ul>
</div>
<div>

	<img src="geogebra_valores.png" width="350%">
</div>


</small>		
</section>
				<section>
					<h3>Branch & Bound</h3>
					<img src="https://c8.alamy.com/comp/2G3D2JM/portrait-of-caspar-von-warnsdorff-caspar-warnsdorff-scholar-told-rudolf-ii-2G3D2JM.jpg" width="130px" height="170px">
					<small> 
						Para el problema propuesto, implementamos Branch and Bound con la heur铆stica de Warnsdorff. 
						La cual prioriza la posici贸n con menos movimientos hacia las casillas. Si una ruta falla, se utiliza Bactracking 
						para probar otras opciones hasta encontrar un recorrido completo o declarar que no existe soluci贸n. 
					</small><br>	
				</section>
				<section>
					<h4>Otras Opciones</h4>
					<div style="background-color: #2E3440; padding: 20px; border-radius: 8px; margin-bottom: 12px;">
						<ol style="color: #D8DEE9; line-height: 1.8;">

							<small>
								<li>
									<strong>Poda por Distancia hacia el Centro del Tablero</strong><br>
									Esta estrategia prioriza los movimientos hacia el centro del tablero. 
								</li>
								<li>
									<strong>Poda por Casillas Visitadas Cercanas</strong><br>
									Este criterio evita movimientos hacia casillas que se encuentran rodeadas de posiciones ya visitadas. 
								</li>
								<li>
									<strong>Poda por Recursividad Controlada</strong><br>
									Limitar la profundidad de la recursi贸n en ciertos casos (tableros muy grandes).
								</li>
								<li>
									<strong>Poda de Movimiento Retornable</strong><br>
									En esta estrategia, se busca que el caballo siempre pueda regresar a 谩reas m谩s abiertas del tablero sin quedar encerrado.
								</li>
								<li>
									<strong>Poda basada en un rbol de Decisi贸n Probabil铆stico</strong><br>
									Para esto se utiliza un modelo probabil铆stico para determinar la "viabilidad" de cada movimiento.
								</li>
							</small>
						</ol>
					</div>
				</section>
				<section>
						<h4>B&B Pseudoc贸digo</h4>
						<textarea style="border: 2px solid #333; padding: 20px; background-color: #44475A; color: white; width: 100%; height: 550px; font-size: 16px; font-family: monospace; white-space: pre-wrap; overflow: auto;" readonly>
	generarTablero(n) //genero matriz nxn con -1
	
	Inicializar movimientos_x=[] //[2, 1, -1, -2, -2, -1, 1, 2]
	Inicializar movimientos_y=[] //[1, 2, 2, 1, -1, -2, -2, -1]
	tablero[pos_x][pos_y]=0 //Inicializo posici贸n inicial
							
	pos = 1 //primera posicion
							
	Si pos recorri贸 todos los casilleros
		Muestro el tablero //print
	
		Si no los recorri贸, reviso los 8 movimientos posibles del caballo, 
		preguntando si es factible primero
	
			Si lo es, los priorizo contando los movimientos posibles hacia las casillas
			//El de menos movimientos es el mas optimo
			Muevo el caballero a la posici贸n mas optima.
	
				Hago recursividad desde el nuevo escaque y chequeo nuevamente
				los movimientos mas optimos posibles. 
				#if(factible(n, board, new_x, new_y, move_x, move_y, pos+1)):
			
			Si no lo es, vuelvo un movimiento atr谩s y pruebo desde el pr贸ximo
			movimiento posible.
			//board[new_x][new_y] = -1
			//i++
							
	Si no tengo mas movimientos imprimo que no hay soluci贸n
						</textarea>
					</section>
				</section>
				<section>
					<h4>Codigo B&B</h4>
					<pre class="language-python">
						<code data-line-numbers="|1-12|14|19-23|24|33-45|41|47-54|52|56-60|59-60|47-54|52-54|41-44|45|24-31|27-31|21-22|28|14-17|62-67|">
def solveKT(n, pos_x, pos_y):

	# Inicializaci贸n Matriz
	board = [[-1 for i in range(n)] for j in range(n)]

	# Movimientos posibles 
	move_x = [2, 1, -1, -2, -2, -1, 1, 2]
	move_y = [1, 2, 2, 1, -1, -2, -2, -1]

	board[pos_x][pos_y] = 0
	pos = 1

	if not solveKTUtil(n, board, pos_x, pos_y, move_x, move_y, pos):
		print("Solution does not exist")
	else:
		printSolution(n, board)

def solveKTUtil(n, board, curr_x, curr_y, move_x, move_y, pos):

	if pos == n**2:
		return True

		next_x, next_y = getNextMove(curr_x, curr_y, board, move_x, move_y)
		if next_x != -1 and next_y != -1:
			board[next_x][next_y] = pos
			if solveKTUtil(n, board, next_x, next_y, move_x, move_y, pos + 1):
				return True
			# Backtracking
			board[next_x][next_y] = -1
	return False

def getNextMove(x, y, board, move_x, move_y):

	min_degree = 8
	next_move = (-1, -1)
	
	for i in range(8):
		new_x, new_y = x + move_x[i], y + move_y[i]
		if isSafe(new_x, new_y, board):
			degree = countNextMoves(new_x, new_y, board, move_x, move_y)
			if degree < min_degree:
				min_degree = degree
				next_move = (new_x, new_y)
	return next_move

def countNextMoves(x, y, board, move_x, move_y):

	count = 0
	for i in range(8):
		new_x, new_y = x + move_x[i], y + move_y[i]
		if isSafe(new_x, new_y, board):
			count += 1
	return count

def isSafe(x, y, board):

	if 0 <= x < len(board) and 0 <= y < len(board) and board[x][y] == -1:
		return True
	return False

def printSolution(n, board):

	for i in range(n):
		for j in range(n):
			print(board[i][j], end=' ')
		print()
						</code>
					</pre>	
				</section>
			<section>
					<h3>Costo B&B</h3>
					<div style="background-color: #2E3440; padding: 20px; border-radius: 8px; margin-bottom: 8px; font-size: 24px;">
						<ol style="color: #D8DEE9; line-height: 1.8;">
						En el peor caso, la complejidad temporal de la regla de Warnsdorff es <strong>(^2x8)</strong>, donde <strong>^2</strong> es el n煤mero de casillas del tablero y 8 es el m谩ximo n煤mero de movimientos posibles del caballo.
						</ol>
					</div>
				</section>
				<section>
					<h3>Comparaciones&B</h3>
				</section>
				<section>
					<h3>Cantidad de pasos</h3>
				</section>
				<section>
					<h3>Distintos tama帽os de tablero</h3>
				</section>
				<section>
					<h3>B&B vs Backtracking</h3>
				</section>
				<section>
					<h3>Preguntas</h3>
				</section>
				<section>
					<pre class="language-python">
						<code class="hljs" data-code="python/main.py" data-line-numbers="|1|3-5|6|7-13|14|15-21|">
						</code>
					</pre>	
				</section>
				<section>
					<pre><code data-line-numbers="3,8-10">
						<table>
						  <tr>
							<td>Apples</td>
							<td>$1</td>
							<td>7</td>
						  </tr>
						  <tr>
							<td>Oranges</td>
							<td>$2</td>
							<td>18</td>
						  </tr>
						</table>
						</code></pre>
				</section>
				
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/externalcode/externalcode.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/

				plugins: [ RevealMarkdown, Externalcode, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
